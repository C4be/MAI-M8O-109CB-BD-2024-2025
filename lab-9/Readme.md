# Лабораторная работа №9

Тема: Глава 10 из [книги](https://edu.postgrespro.ru/sql_primer.pdf). Упр 3, 6, 8

Группа: М8О-109СВ-24

Выполнил: **Гимазетдинов Дмитрий Русланович**

[*вернуться на главную*](./../README.md)

---

## Упражнение 3
### Дано: 

Самостоятельно выполните команду EXPLAIN для запроса, содержащего общее табличное выражение (CTE). Посмотрите, на каком уровне находится узел плана, отвечающий за это выражение, как он оформляется. Учтите, что общие табличные выражения всегда материализуются, т. е. вычисляются однократно и результат их вычисления сохраняется в памяти, а затем все последующие обращения в рамках запроса направляются уже к этому материализованному результату.


### Решение:

Создадим общее табличное выражение:

```sql
demo=# 
EXPLAIN WITH wt_air AS (
    SELECT * FROM aircrafts_tmp
    WHERE aircraft_code IN ('773', '763', 'CN1', 'CR2')
) 
SELECT COUNT(*) FROM wt_air, wt_air AS w2 WHERE wt_air.aircraft_code = w2.aircraft_code;
```
```bash
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Aggregate  (cost=26.67..26.68 rows=1 width=8)
   CTE wt_air
     ->  Seq Scan on aircrafts_tmp  (cost=0.00..25.30 rows=20 width=52)
           Filter: (aircraft_code = ANY ('{773,763,CN1,CR2}'::bpchar[]))
   ->  Hash Join  (cost=0.65..1.33 rows=20 width=0)
         Hash Cond: (wt_air.aircraft_code = w2.aircraft_code)
         ->  CTE Scan on wt_air  (cost=0.00..0.40 rows=20 width=16)
         ->  Hash  (cost=0.40..0.40 rows=20 width=16)
               ->  CTE Scan on wt_air w2  (cost=0.00..0.40 rows=20 width=16)
(9 rows)
```
### Анализ плана выполнения запроса с общим табличным выражением (CTE)

Давайте подробно рассмотрим предоставленный вами план выполнения запроса и убедимся, что общее табличное выражение (CTE) действительно материализуется, как ожидается.

#### Ваш запрос:

```sql
EXPLAIN WITH wt_air AS (
    SELECT * FROM aircrafts_tmp
    WHERE aircraft_code IN ('773', '763', 'CN1', 'CR2')
) 
SELECT COUNT(*) 
FROM wt_air, wt_air AS w2 
WHERE wt_air.aircraft_code = w2.aircraft_code;
```

#### Ваш план выполнения:

```
                                     QUERY PLAN                                  
    -----------------------------------------------------------------------------
     Aggregate  (cost=26.67..26.68 rows=1 width=8)
       CTE wt_air
         ->  Seq Scan on aircrafts_tmp  (cost=0.00..25.30 rows=20 width=52)
               Filter: (aircraft_code = ANY ('{773,763,CN1,CR2}'::bpchar[]))
       ->  Hash Join  (cost=0.65..1.33 rows=20 width=0)
             Hash Cond: (wt_air.aircraft_code = w2.aircraft_code)
             ->  CTE Scan on wt_air  (cost=0.00..0.40 rows=20 width=16)
             ->  Hash  (cost=0.40..0.40 rows=20 width=16)
                   ->  CTE Scan on wt_air w2  (cost=0.00..0.40 rows=20 width=16)
    (9 rows)
```

Разбор плана выполнения

1. **CTE wt_air**:
   - **Seq Scan on aircrafts_tmp**: Здесь выполняется последовательное сканирование таблицы `aircrafts_tmp` с фильтрацией по `aircraft_code`. Это соответствует определению CTE `wt_air`.
   - **Материализация**: Узел `CTE wt_air` указывает на то, что результат CTE был материализован. Это означает, что PostgreSQL выполнил запрос внутри CTE один раз и сохранил результат для дальнейшего использования.

2. **Hash Join**:
   - **Hash Cond**: Условие соединения (`wt_air.aircraft_code = w2.aircraft_code`) используется для выполнения хэш-соединения между двумя экземплярами CTE.
   - **CTE Scan on wt_air** и **CTE Scan on wt_air w2**: Эти узлы указывают на повторное использование материализованного результата CTE `wt_air` в основном запросе. Вместо повторного выполнения самого CTE, PostgreSQL обращается к уже сохранённому результату.

3. **Aggregate**:
   - **Aggregate** выполняет итоговую операцию `COUNT(*)` над результатом соединения.

### Подтверждение материализации CTE

В представленном плане выполнения видно, что:

- **CTE wt_air** выполняется единожды с использованием `Seq Scan` и фильтрацией.
- **CTE Scan on wt_air** и **CTE Scan on wt_air w2** ссылаются на ранее материализованный результат CTE, избегая повторного выполнения исходного запроса CTE.

Это подтверждает, что PostgreSQL действительно материализует CTE, выполняя его один раз и используя сохранённый результат для всех последующих обращений в рамках того же запроса.

---

## Упражнение 6
### Дано: 

Выполните команду EXPLAIN для запроса, в котором использована какая-нибудь из оконных функций. Найдите в плане выполнения запроса узел с именем WindowAgg. Попробуйте объяснить, почему он занимает именно этот уровень в плане.

### Решение:

```sql
EXPLAIN 
SELECT 
    aircraft_code, 
    model, 
    range, 
    ROW_NUMBER() OVER (ORDER BY range) AS row_num
FROM 
    bookings.aircrafts_tmp;
```

Теоретический план запроса:

```bash
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 WindowAgg  (cost=71.17..89.02 rows=1020 width=60)
   ->  Sort  (cost=71.17..73.72 rows=1020 width=52)
         Sort Key: range
         ->  Seq Scan on aircrafts_tmp  (cost=0.00..20.20 rows=1020 width=52)
(4 rows)
```

Давайте посмотрим на выполнение команды `EXPLAIN` для запроса, использующего оконные функции. В нашем случае, предположим, что у нас есть таблица `bookings.aircrafts_tmp` с данными об авиасуднах, и мы хотим использовать оконную функцию для, например, вычисления **ранга** по дальности полёта (`range`) для каждого авиасудна.

Пример запроса с использованием оконной функции `ROW_NUMBER`:

```sql
EXPLAIN
SELECT aircraft_code, model, range,
       ROW_NUMBER() OVER (ORDER BY range DESC) AS range_rank
FROM bookings.aircrafts_tmp;
```

Этот запрос вычисляет порядковый номер (ранг) для каждого авиасудна, сортируя их по дальности полёта (чем выше дальность, тем выше ранг).

### Пример плана выполнения

В результате выполнения команды `EXPLAIN` вы получите что-то вроде:

```
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 WindowAgg  (cost=XX.XX..YY.YY rows=N width=Z)
   ->  Sort  (cost=AA.AA..BB.BB rows=N width=Z)
         Sort Key: aircrafts_tmp.range DESC
         ->  Seq Scan on aircrafts_tmp  (cost=CC.CC..DD.DD rows=N width=Z)
(4 rows)
```

Разбор плана выполнения

1. **WindowAgg**:
   - Узел `WindowAgg` выполняет вычисления оконной функции. В данном случае это функция `ROW_NUMBER() OVER (ORDER BY range DESC)`, которая присваивает каждому ряду его позицию в сортированном наборе.
   - Оконные функции требуют, чтобы данные были отсортированы в соответствии с определённым критерием (`ORDER BY range DESC` в данном случае), поэтому узел `WindowAgg` находится **выше** операции сортировки (`Sort`) в плане.

2. **Sort**:
   - Перед выполнением оконной функции PostgreSQL сортирует строки по столбцу `range` в порядке убывания, как указано в запросе.
   - Узел `Sort` выполняет сортировку данных, после чего они передаются на обработку в узел `WindowAgg`.

3. **Seq Scan on aircrafts_tmp**:
   - Этот узел отвечает за последовательное сканирование таблицы `aircrafts_tmp`. PostgreSQL считывает строки таблицы, после чего передаёт их на сортировку в узел `Sort`.

Почему узел `WindowAgg` находится на этом уровне?

- **Оконные функции зависят от сортированных данных**, поскольку они выполняют вычисления над определённым набором строк, который часто определяется с помощью выражения `OVER (ORDER BY ...)`.
- В данном плане:
  - **Сначала** PostgreSQL считывает данные из таблицы с помощью узла `Seq Scan`.
  - **Затем** узел `Sort` сортирует строки по дальности полёта (`range`).
  - **Наконец** узел `WindowAgg` выполняет оконную функцию, вычисляя ранги на основе отсортированных данных.

Оконные функции выполняются **после сортировки** данных, так как они требуют отсортированного набора строк для корректного выполнения операций. Именно поэтому узел `WindowAgg` находится выше узла `Sort`.

---

## Упражнение 8
### Дано: 

Замена коррелированного подзапроса соединением таблиц является одним из способов повышения производительности. Предположим, что мы задались вопросом: сколько маршрутов обслуживают самолеты каждого типа? При этом нужно учитывать, что может иметь место такая ситуация, когда самолеты какого-либо типа не обслуживают ни одного маршрута. Поэтому необходимо использовать не только представление «Маршруты» (routes), но и таблицу «Самолеты» (aircrafts).

Это первый вариант запроса, в нем используется коррелированный подзапрос.

```sql
EXPLAIN ANALYZE
SELECT  a.aircraft_code AS a_code,
        a.model,
        ( SELECT count( r.aircraft_code )
            FROM routes r
           WHERE r.aircraft_code = a.aircraft_code
        ) AS num_routes
FROM aircrafts a
GROUP BY 1, 2
ORDER BY 3 DESC;
```

А в этом варианте коррелированный подзапрос раскрыт и заменен внешним соединением:

```sql
EXPLAIN ANALYZE
SELECT  a.aircraft_code AS a_code,
        a.model,
        count( r.aircraft_code ) AS num_routes
  FROM aircrafts a
  LEFT 
 OUTER JOIN routes r
    ON r.aircraft_code = a.aircraft_code
 GROUP BY 1, 2
 ORDER BY 3 DESC;
```

Причина использования внешнего соединения в том, что может найтись модель самолета, не обслуживающая ни одного маршрута, и если не использовать внешнее соединение, она вообще не попадет в результирующую выборку.

Исследуйте планы выполнения обоих запросов. Попытайтесь найти объяснение различиям в эффективности их выполнения. Чтобы получить усредненную картину, выполните каждый запрос несколько раз. Поскольку таблицы, участвующие в запросах, небольшие, то различие по абсолютным затратам времени выполнения будет незначительным. Но если бы число строк в таблицах было большим, то экономия ресурсов сервера могла оказаться заметной.

Предложите аналогичную пару запросов к базе данных «Авиаперевозки». Проведите необходимые эксперименты с вашими запросами.

### Решение:

---